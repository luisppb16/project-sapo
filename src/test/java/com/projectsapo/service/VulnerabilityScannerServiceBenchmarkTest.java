/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvBatchResponse;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvResponse;
import com.projectsapo.util.DependencyParser;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class VulnerabilityScannerServiceBenchmarkTest {

  @Mock private Project project;
  @Mock private OsvClient osvClient;
  @Mock private Application application;
  @Mock private Consumer<VulnerabilityScannerService.ScanResult> onResult;

  private MockedStatic<DependencyParser> dependencyParserMock;
  private MockedStatic<ApplicationManager> applicationManagerMock;

  private final AtomicInteger invokeLaterCount = new AtomicInteger(0);

  private VulnerabilityScannerService service;

  @BeforeEach
  void setUp() {
    dependencyParserMock = mockStatic(DependencyParser.class);
    applicationManagerMock = mockStatic(ApplicationManager.class);

    applicationManagerMock.when(ApplicationManager::getApplication).thenReturn(application);

    invokeLaterCount.set(0);
    doAnswer(
            invocation -> {
              invokeLaterCount.incrementAndGet();
              Runnable runnable = invocation.getArgument(0);
              runnable.run();
              return null;
            })
        .when(application)
        .invokeLater(any(Runnable.class));

    // Use a direct executor to run tasks in the same thread for testing
    Executor directExecutor = Runnable::run;
    service = new VulnerabilityScannerService(project, osvClient, directExecutor);
  }

  @AfterEach
  void tearDown() {
    dependencyParserMock.close();
    applicationManagerMock.close();
  }

  @Test
  void benchmarkScanDependencies() {
    int dependencyCount = 1000;
    List<OsvPackage> dependencies = new ArrayList<>();
    List<OsvResponse> responses = new ArrayList<>();

    for (int i = 0; i < dependencyCount; i++) {
        dependencies.add(new OsvPackage("lib-" + i, "Maven", "1.0.0"));
        responses.add(new OsvResponse(Collections.emptyList()));
    }

    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenReturn(dependencies);

    OsvBatchResponse batchResponse = new OsvBatchResponse(responses);

    when(osvClient.checkDependencies(any()))
        .thenReturn(CompletableFuture.completedFuture(Optional.of(batchResponse)));

    long startTime = System.nanoTime();
    service.scanDependencies(onResult).join();
    long endTime = System.nanoTime();

    System.out.println("Execution Time: " + (endTime - startTime) / 1_000_000.0 + " ms");
    System.out.println("invokeLater Calls: " + invokeLaterCount.get());
  }
}
