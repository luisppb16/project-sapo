/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Computable;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvResponse;
import com.projectsapo.model.OsvVulnerability;
import com.projectsapo.service.VulnerabilityScannerService.ScanResult;
import com.projectsapo.util.DependencyParser;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
@DisplayName("VulnerabilityScannerService Test Suite")
class VulnerabilityScannerServiceTest {

  @Mock private Project project;
  @Mock private OsvClient client;
  @Mock private Application application;

  private MockedStatic<ApplicationManager> applicationManagerMock;
  private MockedStatic<DependencyParser> dependencyParserMock;
  private VulnerabilityScannerService service;
  private final Executor directExecutor = Runnable::run;

  @BeforeEach
  void setUp() {
    // Initialize static mocks
    applicationManagerMock = mockStatic(ApplicationManager.class);
    dependencyParserMock = mockStatic(DependencyParser.class);

    // Setup ApplicationManager to return our mock Application
    applicationManagerMock.when(ApplicationManager::getApplication).thenReturn(application);

    // Setup runReadAction to immediately execute the computable
    when(application.runReadAction(any(Computable.class)))
        .thenAnswer(invocation -> ((Computable<?>) invocation.getArgument(0)).compute());

    // Initialize the service with direct executor for deterministic tests
    service = new VulnerabilityScannerService(project, client, directExecutor);
  }

  @AfterEach
  void tearDown() {
    // Close static mocks to prevent leaks
    applicationManagerMock.close();
    dependencyParserMock.close();
  }

  @Nested
  @DisplayName("Happy Path Scenarios")
  class HappyPath {

    @Test
    @DisplayName("should_return_vulnerabilities_when_dependencies_have_issues")
    void shouldReturnVulnerabilities() {
      // Given
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      OsvVulnerability vuln = new OsvVulnerability("CVE-2023-1234", "Desc", null, null, null, null, null);
      OsvResponse response1 = new OsvResponse(List.of(vuln));

      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.completedFuture(Optional.of(
              new com.projectsapo.model.OsvBatchResponse(List.of(response1))
          )));

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      assertThat(results).hasSize(1);
      assertThat(results.get(0).vulnerable()).isTrue();
      assertThat(results.get(0).vulnerabilities()).containsExactly(vuln);
      assertThat(results.get(0).pkg()).isEqualTo(pkg1);
    }

    @Test
    @DisplayName("should_return_empty_when_no_vulnerabilities")
    void shouldReturnEmptyWhenSafe() {
      // Given
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      OsvResponse response1 = new OsvResponse(Collections.emptyList());

      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.completedFuture(Optional.of(
              new com.projectsapo.model.OsvBatchResponse(List.of(response1))
          )));

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      assertThat(results).hasSize(1);
      assertThat(results.get(0).vulnerable()).isFalse();
      assertThat(results.get(0).vulnerabilities()).isEmpty();
    }

    @Test
    @DisplayName("should_return_empty_when_no_dependencies")
    void shouldReturnEmptyWhenNoDependencies() {
      // Given
      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(Collections.emptyList());

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      assertThat(results).isEmpty();
      verify(client, never()).checkDependencies(any());
    }
  }

  @Nested
  @DisplayName("Unhappy Path Scenarios")
  class UnhappyPath {

    @Test
    @DisplayName("should_propagate_error_when_parsing_fails")
    void shouldPropagateErrorWhenParsingFails() {
      // Given
      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenThrow(new RuntimeException("Parsing Error"));

      // When/Then
      assertThatThrownBy(() -> service.scanDependencies().join())
          .isInstanceOf(java.util.concurrent.CompletionException.class)
          .hasCauseInstanceOf(RuntimeException.class)
          .hasMessageContaining("Failed to parse dependencies");
    }

    @Test
    @DisplayName("should_handle_client_failure")
    void shouldHandleClientFailure() {
      // Given
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.failedFuture(new RuntimeException("API Error")));

      // When/Then
      assertThatThrownBy(() -> service.scanDependencies().join())
          .isInstanceOf(java.util.concurrent.CompletionException.class)
          .hasMessageContaining("API Error");
    }

    @Test
    @DisplayName("should_handle_empty_api_response")
    void shouldHandleEmptyApiResponse() {
      // Given
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.completedFuture(Optional.empty()));

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      assertThat(results).isEmpty();
    }
  }

  @Nested
  @DisplayName("Edge Cases")
  class EdgeCases {

    @Test
    @DisplayName("should_handle_mismatched_batch_size")
    void shouldHandleMismatchedBatchSize() {
      // Given: 2 dependencies, but only 1 result from API
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      OsvPackage pkg2 = new OsvPackage("pkg2", "Maven", "1.0.0");
      OsvResponse response1 = new OsvResponse(Collections.emptyList());

      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1, pkg2));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.completedFuture(Optional.of(
              new com.projectsapo.model.OsvBatchResponse(List.of(response1))
          )));

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      // The loop breaks when i >= results.size(), so we get 1 result
      assertThat(results).hasSize(1);
      assertThat(results.get(0).pkg()).isEqualTo(pkg1);
    }

    @Test
    @DisplayName("should_respect_order_of_results")
    void shouldRespectOrderOfResults() {
      // Given
      OsvPackage pkg1 = new OsvPackage("pkg1", "Maven", "1.0.0");
      OsvPackage pkg2 = new OsvPackage("pkg2", "Maven", "2.0.0");

      OsvResponse resp1 = new OsvResponse(Collections.emptyList()); // Safe

      OsvVulnerability vuln = new OsvVulnerability("CVE-2", "Desc", null, null, null, null, null);
      OsvResponse resp2 = new OsvResponse(List.of(vuln)); // Vulnerable

      dependencyParserMock.when(() -> DependencyParser.parseDependencies(project))
          .thenReturn(List.of(pkg1, pkg2));

      when(client.checkDependencies(anyList()))
          .thenReturn(CompletableFuture.completedFuture(Optional.of(
              new com.projectsapo.model.OsvBatchResponse(List.of(resp1, resp2))
          )));

      // When
      List<ScanResult> results = service.scanDependencies().join();

      // Then
      assertThat(results).hasSize(2);
      assertThat(results.get(0).vulnerable()).isFalse();
      assertThat(results.get(1).vulnerable()).isTrue();
      assertThat(results.get(1).pkg()).isEqualTo(pkg2);
    }
  }
}
