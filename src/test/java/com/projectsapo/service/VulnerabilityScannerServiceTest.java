/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvBatchResponse;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvResponse;
import com.projectsapo.model.OsvVulnerability;
import com.projectsapo.util.DependencyParser;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.Consumer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class VulnerabilityScannerServiceTest {

  @Mock private Project project;
  @Mock private OsvClient osvClient;
  @Mock private Application application;
  @Mock private Consumer<VulnerabilityScannerService.ScanResult> onResult;

  private MockedStatic<DependencyParser> dependencyParserMock;
  private MockedStatic<ApplicationManager> applicationManagerMock;

  private VulnerabilityScannerService service;

  @BeforeEach
  void setUp() {
    dependencyParserMock = mockStatic(DependencyParser.class);
    applicationManagerMock = mockStatic(ApplicationManager.class);

    applicationManagerMock.when(ApplicationManager::getApplication).thenReturn(application);

    doAnswer(
            invocation -> {
              Runnable runnable = invocation.getArgument(0);
              runnable.run();
              return null;
            })
        .when(application)
        .invokeLater(any(Runnable.class));

    // Use a direct executor to run tasks in the same thread for testing
    Executor directExecutor = Runnable::run;
    service = new VulnerabilityScannerService(project, osvClient, directExecutor);
  }

  @AfterEach
  void tearDown() {
    dependencyParserMock.close();
    applicationManagerMock.close();
  }

  @Test
  void testScanDependencies_NoDependencies() {
    // Arrange
    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenReturn(List.of());

    // Act
    CompletableFuture<Void> future = service.scanDependencies(onResult);
    future.join();

    // Assert
    verify(osvClient, never()).checkDependencies(any());
    verify(onResult, never()).accept(any());
  }

  @Test
  void testScanDependencies_WithVulnerabilities() {
    // Arrange
    OsvPackage pkg = new OsvPackage("log4j:log4j", "Maven", "1.2.17");
    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenReturn(List.of(pkg));

    OsvVulnerability vuln =
        new OsvVulnerability(
            "GHSA-123", "Summary", "Details", List.of(), List.of(), List.of(), null);
    OsvResponse response = new OsvResponse(List.of(vuln));
    OsvBatchResponse batchResponse = new OsvBatchResponse(List.of(response));

    when(osvClient.checkDependencies(any()))
        .thenReturn(CompletableFuture.completedFuture(Optional.of(batchResponse)));

    // Act
    CompletableFuture<Void> future = service.scanDependencies(onResult);
    future.join();

    // Assert
    verify(onResult, times(1))
        .accept(
            argThat(
                result ->
                    result.pkg().equals(pkg)
                        && result.vulnerable()
                        && result.vulnerabilities().size() == 1));
  }

  @Test
  void testScanDependencies_NoVulnerabilities() {
    // Arrange
    OsvPackage pkg = new OsvPackage("safe-lib:safe", "Maven", "1.0.0");
    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenReturn(List.of(pkg));

    OsvResponse response = new OsvResponse(List.of());
    OsvBatchResponse batchResponse = new OsvBatchResponse(List.of(response));

    when(osvClient.checkDependencies(any()))
        .thenReturn(CompletableFuture.completedFuture(Optional.of(batchResponse)));

    // Act
    CompletableFuture<Void> future = service.scanDependencies(onResult);
    future.join();

    // Assert
    verify(onResult, times(1))
        .accept(
            argThat(
                result ->
                    result.pkg().equals(pkg)
                        && !result.vulnerable()
                        && result.vulnerabilities().isEmpty()));
  }

  @Test
  void testScanDependencies_ClientError() {
    // Arrange
    OsvPackage pkg = new OsvPackage("error-lib:error", "Maven", "1.0.0");
    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenReturn(List.of(pkg));

    when(osvClient.checkDependencies(any()))
        .thenReturn(CompletableFuture.failedFuture(new RuntimeException("API Error")));

    // Act
    CompletableFuture<Void> future = service.scanDependencies(onResult);
    // When using exceptionally, the exception is swallowed and future completes normally (with null).
    // So future.join() shouldn't throw unless the exceptionally block throws.
    try {
        future.join();
    } catch (Exception ignored) {
    }

    // Assert
    verify(onResult, never()).accept(any());
  }

  @Test
  void testScanDependencies_ParserError() {
    // Arrange
    dependencyParserMock
        .when(() -> DependencyParser.parseDependencies(any()))
        .thenThrow(new RuntimeException("Parser Error"));

    // Act
    CompletableFuture<Void> future = service.scanDependencies(onResult);
    future.join();

    // Assert
    verify(osvClient, never()).checkDependencies(any());
    verify(onResult, never()).accept(any());
  }
}
