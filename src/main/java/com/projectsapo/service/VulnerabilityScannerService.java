/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Computable;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvBatchResponse;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvResponse;
import com.projectsapo.model.OsvVulnerability;
import com.projectsapo.util.DependencyParser;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.ForkJoinPool;
import org.jetbrains.annotations.VisibleForTesting;

@Service(Service.Level.PROJECT)
public final class VulnerabilityScannerService {

  private static final Logger LOG = Logger.getInstance(VulnerabilityScannerService.class);
  private final Project project;
  private final OsvClient client;
  private final Executor executor;

  @SuppressWarnings("unused")
  public VulnerabilityScannerService(Project project) {
    this(project, new OsvClient(), ForkJoinPool.commonPool());
  }

  @VisibleForTesting
  public VulnerabilityScannerService(Project project, OsvClient client, Executor executor) {
    this.project = project;
    this.client = client;
    this.executor = executor;
  }

  public static VulnerabilityScannerService getInstance(Project project) {
    return project.getService(VulnerabilityScannerService.class);
  }

  /**
   * Scans project dependencies for vulnerabilities.
   *
   * @return A CompletableFuture that completes with the list of scan results.
   */
  public CompletableFuture<List<ScanResult>> scanDependencies() {
    return CompletableFuture.supplyAsync(
            () -> {
              try {
                return ApplicationManager.getApplication()
                    .runReadAction(
                        (Computable<List<OsvPackage>>)
                            () -> DependencyParser.parseDependencies(project));
              } catch (Exception e) {
                LOG.warn(
                    "[VulnerabilityScannerService#scanDependencies Failed to parse dependencies]",
                    e);
                throw new DependencyScanException("Failed to parse dependencies", e);
              }
            },
            executor)
        .thenCompose(
            dependencies -> {
              if (dependencies == null || dependencies.isEmpty()) {
                LOG.info(
                    "[VulnerabilityScannerService#scanDependencies No dependencies found to scan.]");
                return CompletableFuture.completedFuture(Collections.emptyList());
              }

              return client
                  .checkDependencies(dependencies)
                  .thenApply(
                      responseOpt ->
                          processBatchResponse(dependencies, responseOpt.orElse(null)));
            });
  }

  private List<ScanResult> processBatchResponse(
      List<OsvPackage> dependencies, OsvBatchResponse response) {
    List<ScanResult> resultsList = new ArrayList<>();
    if (response != null) {
      List<OsvResponse> results = response.results();
      if (results.size() != dependencies.size()) {
        LOG.warn(
            "[VulnerabilityScannerService#scanDependencies Batch size mismatch: expected "
                + dependencies.size()
                + ", got "
                + results.size()
                + "]");
      }

      for (int i = 0; i < dependencies.size(); i++) {
        if (i >= results.size()) break;
        OsvPackage dep = dependencies.get(i);
        OsvResponse resp = results.get(i);
        boolean vulnerable = resp.vulns() != null && !resp.vulns().isEmpty();
        List<OsvVulnerability> vulns = vulnerable ? resp.vulns() : List.of();

        resultsList.add(new ScanResult(dep, vulnerable, vulns));
      }
    } else {
      LOG.warn("[VulnerabilityScannerService#scanDependencies Empty batch response]");
    }
    return resultsList;
  }

  public record ScanResult(
      OsvPackage pkg, boolean vulnerable, List<OsvVulnerability> vulnerabilities) {}

  public static class DependencyScanException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    public DependencyScanException(String message, Throwable cause) {
      super(message, cause);
    }
  }
}
