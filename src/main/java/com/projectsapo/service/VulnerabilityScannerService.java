/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvVulnerability;
import com.projectsapo.util.DependencyParser;
import org.jetbrains.annotations.NotNull;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@Service(Service.Level.PROJECT)
public final class VulnerabilityScannerService {

    private static final Logger LOG = Logger.getInstance(VulnerabilityScannerService.class);
    private final Project project;
    private final OsvClient client;

    public VulnerabilityScannerService(Project project) {
        this.project = project;
        this.client = new OsvClient();
    }

    public static VulnerabilityScannerService getInstance(Project project) {
        return project.getService(VulnerabilityScannerService.class);
    }

    /**
     * Scans project dependencies for vulnerabilities.
     *
     * @param onResult Callback for each dependency result.
     * @return A CompletableFuture that completes when all dependencies have been checked.
     */
    public CompletableFuture<Void> scanDependencies(@NotNull Consumer<ScanResult> onResult) {
        return CompletableFuture.runAsync(() -> {
            List<OsvPackage> dependencies;
            try {
                dependencies = DependencyParser.parseDependencies(project);
            } catch (Exception e) {
                LOG.error("Failed to parse dependencies", e);
                return;
            }
            
            if (dependencies.isEmpty()) {
                LOG.info("No dependencies found to scan.");
                return;
            }

            List<CompletableFuture<Void>> futures = dependencies.stream()
                    .map(dep -> client.checkDependency(dep.name(), dep.version(), dep.ecosystem())
                            .thenAccept(response -> {
                                boolean vulnerable = response.isPresent() && response.get().vulns() != null && !response.get().vulns().isEmpty();
                                List<OsvVulnerability> vulns = vulnerable ? response.get().vulns() : List.of();
                                
                                ApplicationManager.getApplication().invokeLater(() -> 
                                    onResult.accept(new ScanResult(dep, vulnerable, vulns))
                                );
                            })
                            .exceptionally(ex -> {
                                LOG.warn("Error checking dependency " + dep.name() + ": " + ex.getMessage());
                                return null;
                            }))
                    .toList();

            try {
                CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();
            } catch (Exception e) {
                LOG.error("Error during vulnerability scan batch execution", e);
            }
        });
    }

    public record ScanResult(OsvPackage pkg, boolean vulnerable, List<OsvVulnerability> vulnerabilities) {}
}
