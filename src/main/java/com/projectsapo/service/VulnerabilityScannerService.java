/*
 * Copyright (c) 2026 Luis Paolo Pepe Barra (@LuisPPB16).
 * All rights reserved.
 */

package com.projectsapo.service;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.projectsapo.client.OsvClient;
import com.projectsapo.model.OsvPackage;
import com.projectsapo.model.OsvResponse;
import com.projectsapo.model.OsvVulnerability;
import com.projectsapo.util.DependencyParser;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.ForkJoinPool;
import java.util.function.Consumer;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.VisibleForTesting;

@Service(Service.Level.PROJECT)
public final class VulnerabilityScannerService {

  private static final Logger LOG = Logger.getInstance(VulnerabilityScannerService.class);
  private final Project project;
  private final OsvClient client;
  private final Executor executor;

  public VulnerabilityScannerService(Project project) {
    this(project, new OsvClient(), ForkJoinPool.commonPool());
  }

  @VisibleForTesting
  public VulnerabilityScannerService(Project project, OsvClient client) {
    this(project, client, ForkJoinPool.commonPool());
  }

  @VisibleForTesting
  public VulnerabilityScannerService(Project project, OsvClient client, Executor executor) {
    this.project = project;
    this.client = client;
    this.executor = executor;
  }

  public static VulnerabilityScannerService getInstance(Project project) {
    return project.getService(VulnerabilityScannerService.class);
  }

  /**
   * Scans project dependencies for vulnerabilities.
   *
   * @param onResult Callback for each dependency result.
   * @return A CompletableFuture that completes when all dependencies have been checked.
   */
  public CompletableFuture<Void> scanDependencies(@NotNull Consumer<ScanResult> onResult) {
    return CompletableFuture.runAsync(
        () -> {
          List<OsvPackage> dependencies;
          try {
            dependencies = DependencyParser.parseDependencies(project);
          } catch (Exception e) {
            LOG.warn("[VulnerabilityScannerService#scanDependencies Failed to parse dependencies]", e);
            return;
          }

          if (dependencies.isEmpty()) {
            LOG.info("[VulnerabilityScannerService#scanDependencies No dependencies found to scan.]");
            return;
          }

          client
              .checkDependencies(dependencies)
              .thenAccept(
                  responseOpt -> {
                    if (responseOpt.isPresent()) {
                      List<OsvResponse> results = responseOpt.get().results();
                      if (results.size() != dependencies.size()) {
                        LOG.warn(
                            "[VulnerabilityScannerService#scanDependencies Batch size mismatch: expected "
                                + dependencies.size()
                                + ", got "
                                + results.size()
                                + "]");
                        // Fallback logic could be added here, but for now we just process what we have if possible or abort
                        // However, OSV usually preserves order.
                      }

                      for (int i = 0; i < dependencies.size(); i++) {
                        if (i >= results.size()) break;
                        OsvPackage dep = dependencies.get(i);
                        OsvResponse resp = results.get(i);
                        boolean vulnerable = resp.vulns() != null && !resp.vulns().isEmpty();
                        List<OsvVulnerability> vulns = vulnerable ? resp.vulns() : List.of();

                        ApplicationManager.getApplication()
                            .invokeLater(() -> onResult.accept(new ScanResult(dep, vulnerable, vulns)));
                      }
                    } else {
                      LOG.warn("[VulnerabilityScannerService#scanDependencies Empty batch response]");
                    }
                  })
              .exceptionally(
                  ex -> {
                    LOG.error(
                        "[VulnerabilityScannerService#scanDependencies Error during batch vulnerability scan]",
                        ex);
                    return null;
                  })
              .join();
        },
        executor);
  }

  public record ScanResult(
      OsvPackage pkg, boolean vulnerable, List<OsvVulnerability> vulnerabilities) {}
}
